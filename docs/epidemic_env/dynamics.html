<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>epidemic_env.dynamics API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>epidemic_env.dynamics</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import yaml
import networkx as nx
import numpy as np
import random as rd

&#34;&#34;&#34; ModelDynamics class
    Handles the epidemic modeling and the parsing of a yaml configuration file.
    This class doesn&#39;t &#34;know&#34; that it&#39;s an RL environment, this part is handled 
    by the wrapper class CountryWideEnv or DistributedEnv which handles the OpenAI gym part of the task.
&#34;&#34;&#34;


class ModelDynamics():

    &#34;&#34;&#34; Initializes the ModelDynamics class, 
        creates a graph and sets epidemic dynamics 
        parameters from a source yaml file

        Parameters : 
            source_file [string] : path to yaml initialization file

        Returns : 
            None
    &#34;&#34;&#34;

    def __init__(self, source_file):
        # loading the parameters from the yaml file
        doc = open(source_file, &#39;r&#39;)
        _params = yaml.safe_load(doc)
        try:
            # simulation parameters
            self.alpha = _params[&#39;alpha&#39;]
            self.var_alpha = _params[&#39;var_alpha&#39;]
            self.beta = _params[&#39;beta&#39;]
            self.var_beta = _params[&#39;var_beta&#39;]
            self.eta = _params[&#39;eta&#39;]
            self.var_eta = _params[&#39;var_eta&#39;]
            self.gamma = _params[&#39;gamma&#39;]
            self.var_gamma = _params[&#39;var_gamma&#39;]
            self.zeta = _params[&#39;zeta&#39;]
            self.var_zeta = _params[&#39;var_zeta&#39;]
            self.tau_0 = _params[&#39;tau_0&#39;]
            self.var_tau_0 = _params[&#39;var_tau_0&#39;]
            self.dt = _params[&#39;dt&#39;]

            # action parameters
            self.confinement_effectiveness = _params[&#39;confinement_effectiveness&#39;]
            self.isolation_effectiveness = _params[&#39;isolation_effectiveness&#39;]
            self.extra_hospital_effectiveness = _params[&#39;extra_hospital_effectiveness&#39;]
            self.vaccination_effectiveness = _params[&#39;vaccination_effectiveness&#39;]
            self.env_step_length = _params[&#39;env_step_lenght&#39;]
            self.srate = _params[&#39;srate&#39;]

            # cities and roads lists
            self.cities = list(_params[&#39;cities&#39;].keys())
            self.n_cities = len(self.cities)
            if _params[&#39;roads&#39;] is not None:
                self.roads = _params[&#39;roads&#39;]
            else:
                self.roads = []

            # generating a graph from the roads and cities
            self.map = nx.Graph()
            self.map.add_nodes_from(self.cities)
            self.map.add_edges_from(self.roads)

            self.pos_map = {}
            for c in self.cities:
                self.map.nodes[c][&#39;pop&#39;] = _params[&#39;cities&#39;][c][&#39;pop&#39;]
                self.pos_map[c] = [_params[&#39;cities&#39;][c]
                                   [&#39;lat&#39;], _params[&#39;cities&#39;][c][&#39;lon&#39;]]

            self.NULL_ACTION = {&#39;confinement&#39;: {c: False for c in self.cities},
                                &#39;isolation&#39;: {c: False for c in self.cities},
                                &#39;hospital&#39;: {c: False for c in self.cities},
                                &#39;vaccinate&#39;: False,
                                }

        except:
            raise(&#34;Invalid YAML scenario file&#34;)

        self.total_pop = np.sum([self.map.nodes[n][&#39;pop&#39;]
                                for n in self.map.nodes()])
        for e in self.roads:
            tau = 10*(self.map.nodes[e[0]][&#39;pop&#39;] *
                      self.map.nodes[e[1]][&#39;pop&#39;])/self.total_pop**2
            self.map.edges[e][&#39;tau&#39;] = tau

        self.reset()

    &#34;&#34;&#34; Resets the dynamical system variables and control parameters
        
        Parameters : 
            None

        Returns : 
            None
    &#34;&#34;&#34;

    def reset(self):
        # initializing the variables
        nx.set_node_attributes(self.map, 1., &#34;s&#34;)
        nx.set_node_attributes(self.map, 0., &#34;e&#34;)
        nx.set_node_attributes(self.map, 0., &#34;i&#34;)
        nx.set_node_attributes(self.map, 0., &#34;r&#34;)
        nx.set_node_attributes(self.map, 0., &#34;d&#34;)

        # initializing the control parameters
        self.c_confined = {c: 1 for c in self.cities}
        self.c_isolated = {c: 1 for c in self.cities}
        self.extra_hospital_beds = {c: 1 for c in self.cities}
        self.vaccinate = {c: 0 for c in self.cities}

    &#34;&#34;&#34; Draws the map on which the epidemic is simulated
        
        Parameters : 
            None

        Returns : 
            None
    &#34;&#34;&#34;

    def draw_map(self,):
        nx.draw(self.map,
                with_labels=True,
                pos=self.pos_map,
                node_size=[self.map.nodes[n][&#39;pop&#39;] /
                           1000 for n in self.map.nodes()],
                width=[self.map.edges[e][&#39;tau&#39;]*10 for e in self.map.edges()]
                )

    &#34;&#34;&#34; Returns the state of the epidemic propagation 
        
        Parameters : 
            None

        Returns : 
            total [dict] : a dict containing the total suceptible, infected, recovered and dead population
            cities [dict] : a dict containing the suceptible, infected, recovered and dead population per city
    &#34;&#34;&#34;

    def epidemic_parameters(self, day=None):
        cities = {}
        suceptible_total = 0
        exposed_total = 0
        infected_total = 0
        recovered_total = 0
        dead_total = 0
        total = 0

        for c in self.cities:
            suceptible = np.max(int(
                np.floor(self.map.nodes[c][&#39;s&#39;] * self.map.nodes[c][&#39;pop&#39;])),0)
            suceptible_total += suceptible
            exposed = np.max(int(
                np.floor(self.map.nodes[c][&#39;e&#39;] * self.map.nodes[c][&#39;pop&#39;])),0)
            exposed_total += exposed
            infected =np.max(int(
                np.floor(self.map.nodes[c][&#39;i&#39;] * self.map.nodes[c][&#39;pop&#39;])),0)
            infected_total += infected
            recovered = np.max(int(
                np.floor(self.map.nodes[c][&#39;r&#39;] * self.map.nodes[c][&#39;pop&#39;])),0)
            recovered_total += recovered
            dead = np.max(int(
                np.floor(self.map.nodes[c][&#39;d&#39;] * self.map.nodes[c][&#39;pop&#39;])))
            dead_total += dead
            total += self.map.nodes[c][&#39;pop&#39;]

            city = {
                &#39;day&#39;: day,
                &#39;suceptible&#39;: suceptible,
                &#39;exposed&#39;: exposed,
                &#39;infected&#39;: infected,
                &#39;recovered&#39;: recovered,
                &#39;dead&#39;: dead,
                &#39;initial population&#39;: self.map.nodes[c][&#39;pop&#39;]
            }
            cities[c] = city

        total = {
            &#39;day&#39;: day,
            &#39;suceptible&#39;: suceptible_total,
            &#39;exposed&#39;: exposed_total,
            &#39;infected&#39;: infected_total,
            &#39;recovered&#39;: recovered_total,
            &#39;dead&#39;: dead_total,
            &#39;initial population&#39;: total
        }

        return total, cities

    &#34;&#34;&#34; Set the action variables in a given city
    
        Parameters :
                act [dict] : a dict containing the following keys with boolean values
                    confine [bool] : should the city be confined?
                    isolate [bool] : should the city be isolated?
                    vaccinate [bool] : should the city be vaccinated?
                    hospital [bool] : should the city be given extra_hospital_beds?
    
    &#34;&#34;&#34;

    def set_action(self, act, city):

        self.c_confined[city] = self.confinement_effectiveness if act[&#39;confinement&#39;] else 1
        self.c_isolated[city] = self.isolation_effectiveness if act[&#39;isolation&#39;] else 1
        self.extra_hospital_beds[city] = self.extra_hospital_effectiveness if act[&#39;hospital&#39;] else 1
        self.vaccinate[city] = self.vaccination_effectiveness if act[&#39;vaccinate&#39;] else 0

    &#34;&#34;&#34;     Starts the epidemic (infects a given proportion 
            of the population in one or more randomly chosen cities)
        
        Parameters : 
            seed [int] : the random seed 
            sources [int] : the number of cities we want the epidemic to start from
            prop [float] : the propotion of the population we initialy infect in a given city

        Returns : 
            None
    &#34;&#34;&#34;

    def start_epidemic(self, seed=10, sources=1, prop=0.01):
        rd.seed(seed)

        start_cities = rd.choices(self.cities, k=sources)
        for c in start_cities:
            self.map.nodes[c][&#39;e&#39;] += prop
            self.map.nodes[c][&#39;s&#39;] -= prop

    &#34;&#34;&#34; Perform one environment step (a week of dynamical system simulation)
        
        Parameters :
            //

        Returns : 
            obs [dict] : a dict containing observation from this step
                    the dict is structured as 
                    total   :   list(dict(measurements)) (over 7 days)
                    city    :   dict(list(dict(measurements))) (over 7 days, per city)
                    pop    :    dict(int) initial per-city population (to allow normalization)

    &#34;&#34;&#34;

    def step(self):
        _total_history = []
        _city_history = []
        # step through a week of simulation to produce one environment step
        for i in range(self.env_step_length*self.srate):
            self.step_dyn()
            total, cities = self.epidemic_parameters()
            _total_history.append(total)
            _city_history.append(cities)

        # output observations
        _total_infected = [t[&#39;infected&#39;]
                           for t in _total_history][0::self.srate]
        _total_dead = [t[&#39;dead&#39;] for t in _total_history][0::self.srate]
        _total = {
            &#39;infected&#39;:    _total_infected,
            &#39;dead&#39;:        _total_dead,
        }
        _city_infected = {c: (
            [t[c][&#39;infected&#39;] for t in _city_history][0::self.srate]) for c in self.cities}
        _city_dead = {c: ([t[c][&#39;dead&#39;] for t in _city_history]
                          [0::self.srate]) for c in self.cities}
        _city = {
            &#39;infected&#39;:    _city_infected,
            &#39;dead&#39;:        _city_dead,
        }
        _pop = {c: self.map.nodes[c][&#39;pop&#39;] for c in self.cities}

        obs = {
            &#39;total&#39;:   _total,
            &#39;city&#39;:   _city,
            &#39;pop&#39;:   _pop
        }
        return obs

    &#34;&#34;&#34; Step forward in the epidemic dynamics
        
        Parameters : 
            None

        Returns : 
            None
    &#34;&#34;&#34;

    def step_dyn(self):
        ds = {}
        de = {}
        di = {}
        dr = {}
        dd = {}

        for c in self.cities:

            # query the variables from the graph
            s = self.map.nodes[c][&#39;s&#39;]
            e = self.map.nodes[c][&#39;e&#39;]
            i = self.map.nodes[c][&#39;i&#39;]
            r = self.map.nodes[c][&#39;r&#39;]
            d = self.map.nodes[c][&#39;d&#39;]

            # compute the derivative terms

            # city - to city contagion
            stoch_t0 = np.max(
                [np.random.normal(self.tau_0, self.var_tau_0), 0])
            sum_term = self.c_isolated[c]*stoch_t0 * np.sum([self.map.nodes[a][&#39;i&#39;]*self.map.edges[(
                a, c)][&#39;tau&#39;]*self.c_isolated[a] for a in nx.neighbors(self.map, c)])

            # incidence rate
            stoch_alpha = np.max(
                [np.random.normal(self.alpha*self.c_confined[c], self.var_alpha), 0])
            new_exposed = stoch_alpha * (s * i + sum_term)

            # vaccination
            stoch_mu = self.vaccination_effectiveness / \
                self.map.nodes[c][&#39;pop&#39;] if self.vaccinate[c] else 0
            new_vaccinated = np.fmax(
                np.fmin(float(stoch_mu*s), float(stoch_mu)), 0)

            # exposure to infection flow
            stoch_eta = np.max([np.random.normal(self.eta, self.eta), 0])
            new_infected = stoch_eta * e

            # exposure to recovered flow
            stoch_beta = np.max(
                [np.random.normal(self.beta, self.var_beta), 0])
            new_recovered = stoch_beta * i

            # death rate
            stoch_zeta = np.max(
                [np.random.normal(self.zeta, self.var_zeta), 0])
            new_deaths = stoch_zeta * i * i * self.extra_hospital_beds[c]

            # loss of immunity rate
            stoch_gamma = np.max(
                [np.random.normal(self.gamma, self.var_gamma), 0])
            new_suceptible = stoch_gamma * r

            # compute the derivatives
            ds[c] = new_suceptible - new_exposed - new_vaccinated
            de[c] = new_exposed - new_infected
            di[c] = new_infected - new_recovered - new_deaths
            dr[c] = new_recovered - new_suceptible + new_vaccinated
            dd[c] = new_deaths

        for c in self.cities:
            # Euler integration step
            self.map.nodes[c][&#39;s&#39;] += ds[c]*self.dt
            self.map.nodes[c][&#39;e&#39;] += de[c]*self.dt
            self.map.nodes[c][&#39;i&#39;] += di[c]*self.dt
            self.map.nodes[c][&#39;r&#39;] += dr[c]*self.dt
            self.map.nodes[c][&#39;d&#39;] += dd[c]*self.dt
            self.map.nodes[c][&#39;s&#39;] = max(self.map.nodes[c][&#39;s&#39;],0)
            self.map.nodes[c][&#39;e&#39;] = max(self.map.nodes[c][&#39;e&#39;],0)
            self.map.nodes[c][&#39;i&#39;] = max(self.map.nodes[c][&#39;i&#39;],0)
            self.map.nodes[c][&#39;r&#39;] = max(self.map.nodes[c][&#39;r&#39;],0)
            self.map.nodes[c][&#39;d&#39;] = max(self.map.nodes[c][&#39;d&#39;],0)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="epidemic_env.dynamics.ModelDynamics"><code class="flex name class">
<span>class <span class="ident">ModelDynamics</span></span>
<span>(</span><span>source_file)</span>
</code></dt>
<dd>
<div class="desc"><p>Initializes the ModelDynamics class,
creates a graph and sets epidemic dynamics
parameters from a source yaml file</p>
<p>Parameters :
source_file [string] : path to yaml initialization file</p>
<p>Returns :
None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ModelDynamics():

    &#34;&#34;&#34; Initializes the ModelDynamics class, 
        creates a graph and sets epidemic dynamics 
        parameters from a source yaml file

        Parameters : 
            source_file [string] : path to yaml initialization file

        Returns : 
            None
    &#34;&#34;&#34;

    def __init__(self, source_file):
        # loading the parameters from the yaml file
        doc = open(source_file, &#39;r&#39;)
        _params = yaml.safe_load(doc)
        try:
            # simulation parameters
            self.alpha = _params[&#39;alpha&#39;]
            self.var_alpha = _params[&#39;var_alpha&#39;]
            self.beta = _params[&#39;beta&#39;]
            self.var_beta = _params[&#39;var_beta&#39;]
            self.eta = _params[&#39;eta&#39;]
            self.var_eta = _params[&#39;var_eta&#39;]
            self.gamma = _params[&#39;gamma&#39;]
            self.var_gamma = _params[&#39;var_gamma&#39;]
            self.zeta = _params[&#39;zeta&#39;]
            self.var_zeta = _params[&#39;var_zeta&#39;]
            self.tau_0 = _params[&#39;tau_0&#39;]
            self.var_tau_0 = _params[&#39;var_tau_0&#39;]
            self.dt = _params[&#39;dt&#39;]

            # action parameters
            self.confinement_effectiveness = _params[&#39;confinement_effectiveness&#39;]
            self.isolation_effectiveness = _params[&#39;isolation_effectiveness&#39;]
            self.extra_hospital_effectiveness = _params[&#39;extra_hospital_effectiveness&#39;]
            self.vaccination_effectiveness = _params[&#39;vaccination_effectiveness&#39;]
            self.env_step_length = _params[&#39;env_step_lenght&#39;]
            self.srate = _params[&#39;srate&#39;]

            # cities and roads lists
            self.cities = list(_params[&#39;cities&#39;].keys())
            self.n_cities = len(self.cities)
            if _params[&#39;roads&#39;] is not None:
                self.roads = _params[&#39;roads&#39;]
            else:
                self.roads = []

            # generating a graph from the roads and cities
            self.map = nx.Graph()
            self.map.add_nodes_from(self.cities)
            self.map.add_edges_from(self.roads)

            self.pos_map = {}
            for c in self.cities:
                self.map.nodes[c][&#39;pop&#39;] = _params[&#39;cities&#39;][c][&#39;pop&#39;]
                self.pos_map[c] = [_params[&#39;cities&#39;][c]
                                   [&#39;lat&#39;], _params[&#39;cities&#39;][c][&#39;lon&#39;]]

            self.NULL_ACTION = {&#39;confinement&#39;: {c: False for c in self.cities},
                                &#39;isolation&#39;: {c: False for c in self.cities},
                                &#39;hospital&#39;: {c: False for c in self.cities},
                                &#39;vaccinate&#39;: False,
                                }

        except:
            raise(&#34;Invalid YAML scenario file&#34;)

        self.total_pop = np.sum([self.map.nodes[n][&#39;pop&#39;]
                                for n in self.map.nodes()])
        for e in self.roads:
            tau = 10*(self.map.nodes[e[0]][&#39;pop&#39;] *
                      self.map.nodes[e[1]][&#39;pop&#39;])/self.total_pop**2
            self.map.edges[e][&#39;tau&#39;] = tau

        self.reset()

    &#34;&#34;&#34; Resets the dynamical system variables and control parameters
        
        Parameters : 
            None

        Returns : 
            None
    &#34;&#34;&#34;

    def reset(self):
        # initializing the variables
        nx.set_node_attributes(self.map, 1., &#34;s&#34;)
        nx.set_node_attributes(self.map, 0., &#34;e&#34;)
        nx.set_node_attributes(self.map, 0., &#34;i&#34;)
        nx.set_node_attributes(self.map, 0., &#34;r&#34;)
        nx.set_node_attributes(self.map, 0., &#34;d&#34;)

        # initializing the control parameters
        self.c_confined = {c: 1 for c in self.cities}
        self.c_isolated = {c: 1 for c in self.cities}
        self.extra_hospital_beds = {c: 1 for c in self.cities}
        self.vaccinate = {c: 0 for c in self.cities}

    &#34;&#34;&#34; Draws the map on which the epidemic is simulated
        
        Parameters : 
            None

        Returns : 
            None
    &#34;&#34;&#34;

    def draw_map(self,):
        nx.draw(self.map,
                with_labels=True,
                pos=self.pos_map,
                node_size=[self.map.nodes[n][&#39;pop&#39;] /
                           1000 for n in self.map.nodes()],
                width=[self.map.edges[e][&#39;tau&#39;]*10 for e in self.map.edges()]
                )

    &#34;&#34;&#34; Returns the state of the epidemic propagation 
        
        Parameters : 
            None

        Returns : 
            total [dict] : a dict containing the total suceptible, infected, recovered and dead population
            cities [dict] : a dict containing the suceptible, infected, recovered and dead population per city
    &#34;&#34;&#34;

    def epidemic_parameters(self, day=None):
        cities = {}
        suceptible_total = 0
        exposed_total = 0
        infected_total = 0
        recovered_total = 0
        dead_total = 0
        total = 0

        for c in self.cities:
            suceptible = np.max(int(
                np.floor(self.map.nodes[c][&#39;s&#39;] * self.map.nodes[c][&#39;pop&#39;])),0)
            suceptible_total += suceptible
            exposed = np.max(int(
                np.floor(self.map.nodes[c][&#39;e&#39;] * self.map.nodes[c][&#39;pop&#39;])),0)
            exposed_total += exposed
            infected =np.max(int(
                np.floor(self.map.nodes[c][&#39;i&#39;] * self.map.nodes[c][&#39;pop&#39;])),0)
            infected_total += infected
            recovered = np.max(int(
                np.floor(self.map.nodes[c][&#39;r&#39;] * self.map.nodes[c][&#39;pop&#39;])),0)
            recovered_total += recovered
            dead = np.max(int(
                np.floor(self.map.nodes[c][&#39;d&#39;] * self.map.nodes[c][&#39;pop&#39;])))
            dead_total += dead
            total += self.map.nodes[c][&#39;pop&#39;]

            city = {
                &#39;day&#39;: day,
                &#39;suceptible&#39;: suceptible,
                &#39;exposed&#39;: exposed,
                &#39;infected&#39;: infected,
                &#39;recovered&#39;: recovered,
                &#39;dead&#39;: dead,
                &#39;initial population&#39;: self.map.nodes[c][&#39;pop&#39;]
            }
            cities[c] = city

        total = {
            &#39;day&#39;: day,
            &#39;suceptible&#39;: suceptible_total,
            &#39;exposed&#39;: exposed_total,
            &#39;infected&#39;: infected_total,
            &#39;recovered&#39;: recovered_total,
            &#39;dead&#39;: dead_total,
            &#39;initial population&#39;: total
        }

        return total, cities

    &#34;&#34;&#34; Set the action variables in a given city
    
        Parameters :
                act [dict] : a dict containing the following keys with boolean values
                    confine [bool] : should the city be confined?
                    isolate [bool] : should the city be isolated?
                    vaccinate [bool] : should the city be vaccinated?
                    hospital [bool] : should the city be given extra_hospital_beds?
    
    &#34;&#34;&#34;

    def set_action(self, act, city):

        self.c_confined[city] = self.confinement_effectiveness if act[&#39;confinement&#39;] else 1
        self.c_isolated[city] = self.isolation_effectiveness if act[&#39;isolation&#39;] else 1
        self.extra_hospital_beds[city] = self.extra_hospital_effectiveness if act[&#39;hospital&#39;] else 1
        self.vaccinate[city] = self.vaccination_effectiveness if act[&#39;vaccinate&#39;] else 0

    &#34;&#34;&#34;     Starts the epidemic (infects a given proportion 
            of the population in one or more randomly chosen cities)
        
        Parameters : 
            seed [int] : the random seed 
            sources [int] : the number of cities we want the epidemic to start from
            prop [float] : the propotion of the population we initialy infect in a given city

        Returns : 
            None
    &#34;&#34;&#34;

    def start_epidemic(self, seed=10, sources=1, prop=0.01):
        rd.seed(seed)

        start_cities = rd.choices(self.cities, k=sources)
        for c in start_cities:
            self.map.nodes[c][&#39;e&#39;] += prop
            self.map.nodes[c][&#39;s&#39;] -= prop

    &#34;&#34;&#34; Perform one environment step (a week of dynamical system simulation)
        
        Parameters :
            //

        Returns : 
            obs [dict] : a dict containing observation from this step
                    the dict is structured as 
                    total   :   list(dict(measurements)) (over 7 days)
                    city    :   dict(list(dict(measurements))) (over 7 days, per city)
                    pop    :    dict(int) initial per-city population (to allow normalization)

    &#34;&#34;&#34;

    def step(self):
        _total_history = []
        _city_history = []
        # step through a week of simulation to produce one environment step
        for i in range(self.env_step_length*self.srate):
            self.step_dyn()
            total, cities = self.epidemic_parameters()
            _total_history.append(total)
            _city_history.append(cities)

        # output observations
        _total_infected = [t[&#39;infected&#39;]
                           for t in _total_history][0::self.srate]
        _total_dead = [t[&#39;dead&#39;] for t in _total_history][0::self.srate]
        _total = {
            &#39;infected&#39;:    _total_infected,
            &#39;dead&#39;:        _total_dead,
        }
        _city_infected = {c: (
            [t[c][&#39;infected&#39;] for t in _city_history][0::self.srate]) for c in self.cities}
        _city_dead = {c: ([t[c][&#39;dead&#39;] for t in _city_history]
                          [0::self.srate]) for c in self.cities}
        _city = {
            &#39;infected&#39;:    _city_infected,
            &#39;dead&#39;:        _city_dead,
        }
        _pop = {c: self.map.nodes[c][&#39;pop&#39;] for c in self.cities}

        obs = {
            &#39;total&#39;:   _total,
            &#39;city&#39;:   _city,
            &#39;pop&#39;:   _pop
        }
        return obs

    &#34;&#34;&#34; Step forward in the epidemic dynamics
        
        Parameters : 
            None

        Returns : 
            None
    &#34;&#34;&#34;

    def step_dyn(self):
        ds = {}
        de = {}
        di = {}
        dr = {}
        dd = {}

        for c in self.cities:

            # query the variables from the graph
            s = self.map.nodes[c][&#39;s&#39;]
            e = self.map.nodes[c][&#39;e&#39;]
            i = self.map.nodes[c][&#39;i&#39;]
            r = self.map.nodes[c][&#39;r&#39;]
            d = self.map.nodes[c][&#39;d&#39;]

            # compute the derivative terms

            # city - to city contagion
            stoch_t0 = np.max(
                [np.random.normal(self.tau_0, self.var_tau_0), 0])
            sum_term = self.c_isolated[c]*stoch_t0 * np.sum([self.map.nodes[a][&#39;i&#39;]*self.map.edges[(
                a, c)][&#39;tau&#39;]*self.c_isolated[a] for a in nx.neighbors(self.map, c)])

            # incidence rate
            stoch_alpha = np.max(
                [np.random.normal(self.alpha*self.c_confined[c], self.var_alpha), 0])
            new_exposed = stoch_alpha * (s * i + sum_term)

            # vaccination
            stoch_mu = self.vaccination_effectiveness / \
                self.map.nodes[c][&#39;pop&#39;] if self.vaccinate[c] else 0
            new_vaccinated = np.fmax(
                np.fmin(float(stoch_mu*s), float(stoch_mu)), 0)

            # exposure to infection flow
            stoch_eta = np.max([np.random.normal(self.eta, self.eta), 0])
            new_infected = stoch_eta * e

            # exposure to recovered flow
            stoch_beta = np.max(
                [np.random.normal(self.beta, self.var_beta), 0])
            new_recovered = stoch_beta * i

            # death rate
            stoch_zeta = np.max(
                [np.random.normal(self.zeta, self.var_zeta), 0])
            new_deaths = stoch_zeta * i * i * self.extra_hospital_beds[c]

            # loss of immunity rate
            stoch_gamma = np.max(
                [np.random.normal(self.gamma, self.var_gamma), 0])
            new_suceptible = stoch_gamma * r

            # compute the derivatives
            ds[c] = new_suceptible - new_exposed - new_vaccinated
            de[c] = new_exposed - new_infected
            di[c] = new_infected - new_recovered - new_deaths
            dr[c] = new_recovered - new_suceptible + new_vaccinated
            dd[c] = new_deaths

        for c in self.cities:
            # Euler integration step
            self.map.nodes[c][&#39;s&#39;] += ds[c]*self.dt
            self.map.nodes[c][&#39;e&#39;] += de[c]*self.dt
            self.map.nodes[c][&#39;i&#39;] += di[c]*self.dt
            self.map.nodes[c][&#39;r&#39;] += dr[c]*self.dt
            self.map.nodes[c][&#39;d&#39;] += dd[c]*self.dt
            self.map.nodes[c][&#39;s&#39;] = max(self.map.nodes[c][&#39;s&#39;],0)
            self.map.nodes[c][&#39;e&#39;] = max(self.map.nodes[c][&#39;e&#39;],0)
            self.map.nodes[c][&#39;i&#39;] = max(self.map.nodes[c][&#39;i&#39;],0)
            self.map.nodes[c][&#39;r&#39;] = max(self.map.nodes[c][&#39;r&#39;],0)
            self.map.nodes[c][&#39;d&#39;] = max(self.map.nodes[c][&#39;d&#39;],0)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="epidemic_env.dynamics.ModelDynamics.draw_map"><code class="name flex">
<span>def <span class="ident">draw_map</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def draw_map(self,):
    nx.draw(self.map,
            with_labels=True,
            pos=self.pos_map,
            node_size=[self.map.nodes[n][&#39;pop&#39;] /
                       1000 for n in self.map.nodes()],
            width=[self.map.edges[e][&#39;tau&#39;]*10 for e in self.map.edges()]
            )</code></pre>
</details>
</dd>
<dt id="epidemic_env.dynamics.ModelDynamics.epidemic_parameters"><code class="name flex">
<span>def <span class="ident">epidemic_parameters</span></span>(<span>self, day=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def epidemic_parameters(self, day=None):
    cities = {}
    suceptible_total = 0
    exposed_total = 0
    infected_total = 0
    recovered_total = 0
    dead_total = 0
    total = 0

    for c in self.cities:
        suceptible = np.max(int(
            np.floor(self.map.nodes[c][&#39;s&#39;] * self.map.nodes[c][&#39;pop&#39;])),0)
        suceptible_total += suceptible
        exposed = np.max(int(
            np.floor(self.map.nodes[c][&#39;e&#39;] * self.map.nodes[c][&#39;pop&#39;])),0)
        exposed_total += exposed
        infected =np.max(int(
            np.floor(self.map.nodes[c][&#39;i&#39;] * self.map.nodes[c][&#39;pop&#39;])),0)
        infected_total += infected
        recovered = np.max(int(
            np.floor(self.map.nodes[c][&#39;r&#39;] * self.map.nodes[c][&#39;pop&#39;])),0)
        recovered_total += recovered
        dead = np.max(int(
            np.floor(self.map.nodes[c][&#39;d&#39;] * self.map.nodes[c][&#39;pop&#39;])))
        dead_total += dead
        total += self.map.nodes[c][&#39;pop&#39;]

        city = {
            &#39;day&#39;: day,
            &#39;suceptible&#39;: suceptible,
            &#39;exposed&#39;: exposed,
            &#39;infected&#39;: infected,
            &#39;recovered&#39;: recovered,
            &#39;dead&#39;: dead,
            &#39;initial population&#39;: self.map.nodes[c][&#39;pop&#39;]
        }
        cities[c] = city

    total = {
        &#39;day&#39;: day,
        &#39;suceptible&#39;: suceptible_total,
        &#39;exposed&#39;: exposed_total,
        &#39;infected&#39;: infected_total,
        &#39;recovered&#39;: recovered_total,
        &#39;dead&#39;: dead_total,
        &#39;initial population&#39;: total
    }

    return total, cities</code></pre>
</details>
</dd>
<dt id="epidemic_env.dynamics.ModelDynamics.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self):
    # initializing the variables
    nx.set_node_attributes(self.map, 1., &#34;s&#34;)
    nx.set_node_attributes(self.map, 0., &#34;e&#34;)
    nx.set_node_attributes(self.map, 0., &#34;i&#34;)
    nx.set_node_attributes(self.map, 0., &#34;r&#34;)
    nx.set_node_attributes(self.map, 0., &#34;d&#34;)

    # initializing the control parameters
    self.c_confined = {c: 1 for c in self.cities}
    self.c_isolated = {c: 1 for c in self.cities}
    self.extra_hospital_beds = {c: 1 for c in self.cities}
    self.vaccinate = {c: 0 for c in self.cities}</code></pre>
</details>
</dd>
<dt id="epidemic_env.dynamics.ModelDynamics.set_action"><code class="name flex">
<span>def <span class="ident">set_action</span></span>(<span>self, act, city)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_action(self, act, city):

    self.c_confined[city] = self.confinement_effectiveness if act[&#39;confinement&#39;] else 1
    self.c_isolated[city] = self.isolation_effectiveness if act[&#39;isolation&#39;] else 1
    self.extra_hospital_beds[city] = self.extra_hospital_effectiveness if act[&#39;hospital&#39;] else 1
    self.vaccinate[city] = self.vaccination_effectiveness if act[&#39;vaccinate&#39;] else 0</code></pre>
</details>
</dd>
<dt id="epidemic_env.dynamics.ModelDynamics.start_epidemic"><code class="name flex">
<span>def <span class="ident">start_epidemic</span></span>(<span>self, seed=10, sources=1, prop=0.01)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_epidemic(self, seed=10, sources=1, prop=0.01):
    rd.seed(seed)

    start_cities = rd.choices(self.cities, k=sources)
    for c in start_cities:
        self.map.nodes[c][&#39;e&#39;] += prop
        self.map.nodes[c][&#39;s&#39;] -= prop</code></pre>
</details>
</dd>
<dt id="epidemic_env.dynamics.ModelDynamics.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self):
    _total_history = []
    _city_history = []
    # step through a week of simulation to produce one environment step
    for i in range(self.env_step_length*self.srate):
        self.step_dyn()
        total, cities = self.epidemic_parameters()
        _total_history.append(total)
        _city_history.append(cities)

    # output observations
    _total_infected = [t[&#39;infected&#39;]
                       for t in _total_history][0::self.srate]
    _total_dead = [t[&#39;dead&#39;] for t in _total_history][0::self.srate]
    _total = {
        &#39;infected&#39;:    _total_infected,
        &#39;dead&#39;:        _total_dead,
    }
    _city_infected = {c: (
        [t[c][&#39;infected&#39;] for t in _city_history][0::self.srate]) for c in self.cities}
    _city_dead = {c: ([t[c][&#39;dead&#39;] for t in _city_history]
                      [0::self.srate]) for c in self.cities}
    _city = {
        &#39;infected&#39;:    _city_infected,
        &#39;dead&#39;:        _city_dead,
    }
    _pop = {c: self.map.nodes[c][&#39;pop&#39;] for c in self.cities}

    obs = {
        &#39;total&#39;:   _total,
        &#39;city&#39;:   _city,
        &#39;pop&#39;:   _pop
    }
    return obs</code></pre>
</details>
</dd>
<dt id="epidemic_env.dynamics.ModelDynamics.step_dyn"><code class="name flex">
<span>def <span class="ident">step_dyn</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step_dyn(self):
    ds = {}
    de = {}
    di = {}
    dr = {}
    dd = {}

    for c in self.cities:

        # query the variables from the graph
        s = self.map.nodes[c][&#39;s&#39;]
        e = self.map.nodes[c][&#39;e&#39;]
        i = self.map.nodes[c][&#39;i&#39;]
        r = self.map.nodes[c][&#39;r&#39;]
        d = self.map.nodes[c][&#39;d&#39;]

        # compute the derivative terms

        # city - to city contagion
        stoch_t0 = np.max(
            [np.random.normal(self.tau_0, self.var_tau_0), 0])
        sum_term = self.c_isolated[c]*stoch_t0 * np.sum([self.map.nodes[a][&#39;i&#39;]*self.map.edges[(
            a, c)][&#39;tau&#39;]*self.c_isolated[a] for a in nx.neighbors(self.map, c)])

        # incidence rate
        stoch_alpha = np.max(
            [np.random.normal(self.alpha*self.c_confined[c], self.var_alpha), 0])
        new_exposed = stoch_alpha * (s * i + sum_term)

        # vaccination
        stoch_mu = self.vaccination_effectiveness / \
            self.map.nodes[c][&#39;pop&#39;] if self.vaccinate[c] else 0
        new_vaccinated = np.fmax(
            np.fmin(float(stoch_mu*s), float(stoch_mu)), 0)

        # exposure to infection flow
        stoch_eta = np.max([np.random.normal(self.eta, self.eta), 0])
        new_infected = stoch_eta * e

        # exposure to recovered flow
        stoch_beta = np.max(
            [np.random.normal(self.beta, self.var_beta), 0])
        new_recovered = stoch_beta * i

        # death rate
        stoch_zeta = np.max(
            [np.random.normal(self.zeta, self.var_zeta), 0])
        new_deaths = stoch_zeta * i * i * self.extra_hospital_beds[c]

        # loss of immunity rate
        stoch_gamma = np.max(
            [np.random.normal(self.gamma, self.var_gamma), 0])
        new_suceptible = stoch_gamma * r

        # compute the derivatives
        ds[c] = new_suceptible - new_exposed - new_vaccinated
        de[c] = new_exposed - new_infected
        di[c] = new_infected - new_recovered - new_deaths
        dr[c] = new_recovered - new_suceptible + new_vaccinated
        dd[c] = new_deaths

    for c in self.cities:
        # Euler integration step
        self.map.nodes[c][&#39;s&#39;] += ds[c]*self.dt
        self.map.nodes[c][&#39;e&#39;] += de[c]*self.dt
        self.map.nodes[c][&#39;i&#39;] += di[c]*self.dt
        self.map.nodes[c][&#39;r&#39;] += dr[c]*self.dt
        self.map.nodes[c][&#39;d&#39;] += dd[c]*self.dt
        self.map.nodes[c][&#39;s&#39;] = max(self.map.nodes[c][&#39;s&#39;],0)
        self.map.nodes[c][&#39;e&#39;] = max(self.map.nodes[c][&#39;e&#39;],0)
        self.map.nodes[c][&#39;i&#39;] = max(self.map.nodes[c][&#39;i&#39;],0)
        self.map.nodes[c][&#39;r&#39;] = max(self.map.nodes[c][&#39;r&#39;],0)
        self.map.nodes[c][&#39;d&#39;] = max(self.map.nodes[c][&#39;d&#39;],0)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="epidemic_env" href="index.html">epidemic_env</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="epidemic_env.dynamics.ModelDynamics" href="#epidemic_env.dynamics.ModelDynamics">ModelDynamics</a></code></h4>
<ul class="two-column">
<li><code><a title="epidemic_env.dynamics.ModelDynamics.draw_map" href="#epidemic_env.dynamics.ModelDynamics.draw_map">draw_map</a></code></li>
<li><code><a title="epidemic_env.dynamics.ModelDynamics.epidemic_parameters" href="#epidemic_env.dynamics.ModelDynamics.epidemic_parameters">epidemic_parameters</a></code></li>
<li><code><a title="epidemic_env.dynamics.ModelDynamics.reset" href="#epidemic_env.dynamics.ModelDynamics.reset">reset</a></code></li>
<li><code><a title="epidemic_env.dynamics.ModelDynamics.set_action" href="#epidemic_env.dynamics.ModelDynamics.set_action">set_action</a></code></li>
<li><code><a title="epidemic_env.dynamics.ModelDynamics.start_epidemic" href="#epidemic_env.dynamics.ModelDynamics.start_epidemic">start_epidemic</a></code></li>
<li><code><a title="epidemic_env.dynamics.ModelDynamics.step" href="#epidemic_env.dynamics.ModelDynamics.step">step</a></code></li>
<li><code><a title="epidemic_env.dynamics.ModelDynamics.step_dyn" href="#epidemic_env.dynamics.ModelDynamics.step_dyn">step_dyn</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>